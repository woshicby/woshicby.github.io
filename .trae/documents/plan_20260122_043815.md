# 文明演化游戏事件系统改进计划

## 功能概述
为游戏中的基础随机事件（internal、diplomatic、war、trade、global）添加符合逻辑的发生条件和效果，实现战争和贸易的相邻限制，以及事件对格子的影响和文明内资源调度机制。

## 实现方案

### 1. 事件系统架构改进

#### 1.1 事件基础结构扩展
- 为每个事件添加`triggeredBy`字段，记录事件触发的原因
- 为每个事件添加`affectedCells`字段，记录受影响的格子
- 为每个事件添加`duration`字段，记录事件持续时间（如果是持续性事件）

#### 1.2 事件管理器
- 添加事件管理器类，统一处理事件的生成、触发和效果
- 实现事件队列，支持持续性事件的管理

### 2. 各类型事件设计

#### 2.1 Internal（内部事件）

**发生条件：**
- 文明人口超过20000
- 文明综合实力超过100
- 文明内部属性差异超过30

**发生效果：**
- 随机选择文明内的一个区域进行资源调度
- 从高属性区域向低属性区域转移资源
- 提升文明内部稳定性

**具体实现：**
```javascript
// 资源调度逻辑
const sourceCell = // 选择属性较高的格子
const targetCell = // 选择属性较低的格子
// 转移资源
const transferAmount = Math.min(sourceCell.tech * 0.1, targetCell.limits.tech - targetCell.tech);
targetCell.tech += transferAmount;
sourceCell.tech -= transferAmount;
// 同样处理其他属性
```

#### 2.2 Diplomatic（外交事件）

**发生条件：**
- 两个文明关系值在-20到50之间
- 两个文明地理位置相邻
- 两个文明文化差异低于30

**发生效果：**
- 随机提升或降低两个文明的关系值
- 可能触发贸易或战争事件
- 影响边境格子的属性

**具体实现：**
```javascript
// 随机调整关系值
const relationChange = Math.random() * 20 - 10;
civ1.relations[civ2.id] += relationChange;
civ2.relations[civ1.id] += relationChange;
// 限制关系值范围
civ1.relations[civ2.id] = Math.max(-100, Math.min(100, civ1.relations[civ2.id]));
civ2.relations[civ2.id] = Math.max(-100, Math.min(100, civ2.relations[civ1.id]));
```

#### 2.3 War（战争事件）

**发生条件：**
- 两个文明关系值低于-30
- 两个文明地理位置相邻
- 至少一个文明的军事力量超过50

**发生效果：**
- 随机选择边境格子进行战斗
- 降低战斗格子的经济和人口属性
- 提升胜利方的军事属性
- 降低双方的关系值

**具体实现：**
```javascript
// 选择边境格子
const borderCells = // 找到两个文明相邻的格子
const battleCell = borderCells[Math.floor(Math.random() * borderCells.length)];
// 战斗效果
battleCell.economy *= 0.8;
battleCell.population *= 0.9;
// 提升胜利方军事属性
victorCivilization.military *= 1.1;
// 降低双方关系
civ1.relations[civ2.id] -= 20;
civ2.relations[civ1.id] -= 20;
```

#### 2.4 Trade（贸易事件）

**发生条件：**
- 两个文明关系值高于30
- 两个文明地理位置相邻
- 两个文明经济实力均超过40

**发生效果：**
- 随机选择边境格子进行贸易
- 提升双方贸易格子的经济属性
- 提升双方的关系值
- 可能触发文化交流，提升文化属性

**具体实现：**
```javascript
// 选择边境格子
const borderCells = // 找到两个文明相邻的格子
const tradeCell = borderCells[Math.floor(Math.random() * borderCells.length)];
// 贸易效果
tradeCell.economy *= 1.2;
tradeCell.culture *= 1.1;
// 提升双方关系
civ1.relations[civ2.id] += 10;
civ2.relations[civ1.id] += 10;
```

#### 2.5 Global（全球事件）

**发生条件：**
- 随机触发（概率较低）
- 游戏运行时间超过1000年
- 至少存在3个文明

**发生效果：**
- 影响所有文明的所有格子
- 随机提升或降低所有格子的属性
- 可能触发文明的衰退或繁荣

**具体实现：**
```javascript
// 全球事件效果
const globalEffect = Math.random() * 0.4 - 0.2; // -20% 到 +20%
for (let y = 0; y < this.rows; y++) {
    for (let x = 0; x < this.cols; x++) {
        const cell = this.territory[y][x];
        cell.tech *= (1 + globalEffect);
        cell.culture *= (1 + globalEffect);
        cell.economy *= (1 + globalEffect);
        cell.military *= (1 + globalEffect);
        cell.population *= (1 + globalEffect);
    }
}
```

### 3. 文明内资源调度机制

**实现方式：**
- 在文明的`updateStats`方法中添加资源调度逻辑
- 当文明内部属性差异超过阈值时，自动从高属性格子向低属性格子转移资源
- 资源转移量基于格子间的属性差异和距离

**具体实现：**
```javascript
// 文明内资源调度
if (this.isUnstable) {
    // 收集所有格子
    const ownedCells = // 收集文明所有格子
    // 计算平均属性
    const avgTech = ownedCells.reduce((sum, cell) => sum + cell.tech, 0) / ownedCells.length;
    // 转移资源
    ownedCells.forEach(cell => {
        if (cell.tech > avgTech * 1.2) {
            const transferAmount = cell.tech - avgTech * 1.2;
            cell.tech -= transferAmount;
            // 分配给其他格子
            // ...
        }
    });
}
```

### 4. 事件触发与管理

**实现方式：**
- 修改`generateRandomEvent`方法，为每种事件添加发生条件检查
- 实现事件效果的具体逻辑
- 添加事件日志，记录事件的详细信息

**具体实现：**
```javascript
// 修改后的generateRandomEvent方法
generateRandomEvent() {
    // 检查各种事件的发生条件
    if (this.checkWarConditions()) {
        this.triggerWarEvent();
    } else if (this.checkTradeConditions()) {
        this.triggerTradeEvent();
    } else if (this.checkDiplomaticConditions()) {
        this.triggerDiplomaticEvent();
    } else if (this.checkInternalConditions()) {
        this.triggerInternalEvent();
    } else if (this.checkGlobalConditions()) {
        this.triggerGlobalEvent();
    }
    // 限制事件数量
    if (this.events.length > 50) {
        this.events.shift();
    }
}
```

## 代码修改计划

### 1. 修改Simulator类
- 扩展事件基础结构
- 修改`generateRandomEvent`方法，添加事件条件检查
- 实现各种事件的触发和效果逻辑
- 添加文明内资源调度机制

### 2. 修改Civilization类
- 在`updateStats`方法中添加资源调度相关逻辑

### 3. 修改MapSystem类
- 添加寻找相邻文明格子的方法
- 添加格子属性修改的辅助方法

### 4. 修改UISystem类
- 更新事件显示，展示更详细的事件信息
- 添加事件影响的可视化效果

## 预期效果
- 事件系统更加丰富和真实
- 战争和贸易只能发生在相邻文明之间
- 事件对格子产生实际影响
- 文明内自动进行资源调度
- 事件描述更加详细和有意义
- 游戏的策略性和趣味性增强

## 技术要点
- 确保事件条件检查的效率
- 实现事件效果的合理计算
- 处理好资源调度的平衡性
- 确保事件描述的多样性和准确性
- 保持代码的模块化和可扩展性